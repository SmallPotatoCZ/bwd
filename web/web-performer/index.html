<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
<meta content='width=device-width, initial-scale=1.0' name='viewport'>
<link href='/favicon.png' rel='shortcut icon'>
<meta content='' name='app:pageurl'>







<link rel="canonical" href="">
<meta name="og:url" content="">













    <title>EsilyZhang 的备忘单</title>
    
    <link rel="stylesheet" href="/sass/home.min.de7c29548feadde2ec038bd703cb5297c0c0d6ae56e095e1f9e1d89f08855611.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    

<link rel="stylesheet" href="/sass/post.min.73af919387c4b2c68aada5d541dadec89e4cf1f095f2b0e7fb1445046b5e955a.css">

</head>

<body>
    <header role="heading">
        <nav class='top-nav' data-js-no-preview role='navigation'>
    <div class='container'>
        
        <div class='left'>
            <a class='back-button icons' href='/'>keyboard_backspace</a>
        </div>
        

        <a class='brand' href='/'>
            EsilyZhang 的备忘单
        </a>
    </div>
</nav>
    </header>
    <main role="main">
        
<div class='site-header' role='banner'>
    <h1>
        Web Performer - 笔记
    </h1>
</div>
<div>
    

<h2 id="web-性能">Web 性能</h2>

<h3 id="加载快">加载快</h3>

<h4 id="服务器的返回快">服务器的返回快</h4>

<h4 id="web-自身加载快和渲染快">web 自身加载快和渲染快</h4>

<h5 id="javascript">JavaScript</h5>

<h6 id="压缩-minify">压缩（Minify）</h6>

<p>####### webpack
mode: &lsquo;production&rsquo;</p>

<p>####### Babel
babel-preset-minify</p>

<p>####### Gulp
gulp-uglify</p>

<h6 id="async-defer">Async &amp;&amp; Defer</h6>

<p>浏览器加载网页的过程：
1. 开始加载 HTML 文档
2. 解析 HTML
3. 如果遇到 script 标签，暂停解析 HTML，开始下载脚本，执行脚本
4. 继续解析
5. 渲染</p>

<p>Async 是异步下载脚本，一旦完成下载，立即执行；</p>

<p>Defer 是异步下载脚本，但是只有在 HTML 解析完成才会开始执行；</p>

<p>两者还有重要的不同是：Async 不能保证脚本执行的顺序，而 Defer 会在所有脚本下载完成才会执行，保证正确的顺序。</p>

<h6 id="代码分割">代码分割</h6>

<p>对于多页的 Web 应用，使用一个 Bundle.js 增加了页面加载的时间。</p>

<p>通过将代码分割，可以根据应用的功能加载相应功能的 js 代码。</p>

<p>分隔的代码如何使用：</p>

<p>首先，像 Webpack、Parcel 或 Rollup等工具，支持的 <code>import</code> 函数。<code>import</code> 函数会将 <code>import</code> 中引入的文件，包含文件中引入的依赖，都会打包成一个独立的块文件。只有当在应用通过<code>import</code>调用文件时，才会加载模块。</p>

<p>浏览器中的 <code>import</code> 是异步下载的方式。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#080;font-weight:bold">import</span>(<span style="background-color:#fff0f0">&#34;./module.js&#34;</span>)
	.then(m =&gt; {
    	console.log(m.<span style="color:#080;font-weight:bold">default</span>);
    })
</code></pre></div>
<p>其次，对于 Vue 和 React 中有借助<code>import</code>相应的辅助工具。如：React 中的 <a href="https://github.com/jamiebuilds/react-loadable"><code>react-loadable</code></a>和内置的<a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense"><code>Suspense</code></a>; Vue 中的<a href="https://vuejs.org/v2/guide/components-dynamic-async.html#Async-Components">异步组件</a></p>

<h6 id="优化代码依赖">优化代码依赖</h6>

<p>移除依赖中不需要的代码部分。Google 的<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations">依赖库优化</a></p>

<h5 id="css">CSS</h5>

<h6 id="压缩-minify-1">压缩（Minify）</h6>

<p>####### Webpack
postcss-loader</p>

<p>####### PostCSS
cssnano</p>

<p>####### gulp-clean-css</p>

<h6 id="分离出重要-css">分离出重要 CSS</h6>

<p>将 CSS 分离出重要的 CSS 和非重要的 CSS。</p>

<p>重要的 CSS 可以简单理解为页面内容块的布局位置，要通过内联方式加载。</p>

<p>非重要的 CSS，通过<code>&lt;link rel=&quot;preload&quot; href=&quot;non-critical.css&quot; as=&quot;style&quot; onload=&quot;this.rel ='stylesheet'&quot; /&gt;</code>方式加载，将 CSS 文件变成优先的下载权限。</p>

<h5 id="http">HTTP</h5>

<p>在网络方面进行优化。</p>

<h6 id="压缩-html">压缩 HTML</h6>

<h6 id="压缩内容中的文本">压缩内容中的文本</h6>

<p>####### Gzip</p>

<p><a href="https://httpd.apache.org/docs/2.4/mod/mod_deflate.html#recommended">Apache 服务配置压缩</a></p>

<p><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html#example">Nginx 服务配置压缩</a></p>

<p>####### Brotli</p>

<p><a href="https://httpd.apache.org/docs/trunk/mod/mod_brotli.html#recommended">Apache 服务配置压缩</a></p>

<p><a href="https://github.com/google/ngx_brotli">Nginx 服务配置压缩</a></p>

<h6 id="cdn">CDN</h6>

<h6 id="优先加载资源">优先加载资源</h6>

<p>preload 的五种方式：</p>

<ol>
<li>preload - 主机渲染之前就开始加载，不易阻塞页面的初步下渲染。</li>
<li>dns-prefetch - 浏览器主动去执行域名解析的功能。提前知道的主机 ip 地址能够节约 50-300 ms。如：<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://www.spreadfirefox.com/&quot;&gt;</code>。</li>
<li>preconnect - 提前建立到服务器的连接。在配合 dns-prefetch 时非常有用。但是它非常消耗资源，限制使用它才是合理的。</li>
<li>prefetch - 使用浏览器空闲的时间去下载资源或者预取用户将来可能使用的资源。浏览器在完成当前页面的加载和开始静默下载这些资源并存储在缓存中。</li>

<li><p>prerender - 在后台提前下载指定的页并在不可见的标签页渲染它。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#070">link</span> <span style="color:#00c">rel</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;dns-perfetch&#34;</span> <span style="color:#00c">href</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;//example.com&#34;</span>&gt;
&lt;<span style="color:#070">link</span> <span style="color:#00c">rel</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;preconnect&#34;</span> <span style="color:#00c">href</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;https://example.com&#34;</span>&gt;
&lt;<span style="color:#070">link</span> <span style="color:#00c">rel</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;prefetch&#34;</span> <span style="color:#00c">href</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;/style.css&#34;</span> <span style="color:#00c">as</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;style&#34;</span>&gt;
&lt;<span style="color:#070">link</span> <span style="color:#00c">rel</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;preload&#34;</span> <span style="color:#00c">href</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;/style.css&#34;</span> <span style="color:#00c">as</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;style&#34;</span>&gt;
&lt;<span style="color:#070">link</span> <span style="color:#00c">rel</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;prerender&#34;</span> <span style="color:#00c">href</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;https://examplre.com/about/&#34;</span> &gt;</code></pre></div></li>
</ol>

<h5 id="图片">图片</h5>

<p>常用的图片类型：
1. svg - 最好的矢量图片，图标和logo
2. jpg - 最好的照片格式，将人眼不可见的图片质量放弃来达成图片压缩
3. png - 不像丢失图片的任何质量，如：雪碧图或像素图
4. webp - 对于雪碧图和相片都好，但是只有 Chrome 中支持。可以通过<code>&lt;picture&gt;</code>实现渐进。
5. gif - 不要使用 gif，而是使用压缩的 video。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#070">picture</span>&gt;
	&lt;<span style="color:#070">source</span> <span style="color:#00c">srcset</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;img.webp&#34;</span> <span style="color:#00c">type</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;image/webp&#34;</span> &gt;
    &lt;<span style="color:#070">img</span> <span style="color:#00c">src</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;img.jpg&#34;</span> <span style="color:#00c">type</span><span style="color:#333">=</span><span style="background-color:#fff0f0">&#34;image/jpeg&#34;</span>&gt;
&lt;/<span style="color:#070">picture</span>&gt;</code></pre></div>
<p>一、<code>svg</code>：</p>

<ul>
<li>压缩，移除注释和空格</li>
<li>简化路径，从编辑软件导出的 svg 路径将会时复杂的

<ul>
<li>简化文件结构，从编辑软件的导出的文件会包含额外的元元素，移除它们。</li>
</ul></li>
</ul>

<p>优化 svg 文件的工具：</p>

<ol>
<li><a href="https://github.com/svg/svgo">svgo-nodejs</a></li>
<li><a href="https://jakearchibald.github.io/svgomg/">svgo-可视化</a></li>
</ol>

<p>二、<code>jpg</code></p>

<ul>
<li>减少图片的大小；渐进式加载工具：<a href="https://github.com/herrstucki/responsive-loader">webpack 的 loader</a>；对于高清的图片要使用渐进式图片<code>&lt;picture&gt;</code>或者<code>&lt;img srcset&gt;</code></li>
<li>压缩图片的质量，降到 70%，大小将会降低至 6 倍，<a href="https://www.npmjs.com/package/image-webpack-loader">工具</a></li>
</ul>

<p>三、<code>png</code></p>

<ul>
<li>交错格式 png。先以低的像素质量渲染然后逐渐改善。对于 png 图标不合适。</li>
<li>使用索引颜色。将所用的颜色放置在调色板中，图片数据使用颜色的索引。对于包含多种颜色的图片不适用。<a href="https://www.npmjs.com/package/image-webpack-loader">工具</a>。</li>
</ul>

<h6 id="压缩图片尺寸">压缩图片尺寸</h6>

<h6 id="压缩图片质量">压缩图片质量</h6>

<h6 id="渐进式显示">渐进式显示</h6>

<h5 id="字体">字体</h5>

<ol>
<li>设置回退字体列表，<code>font-family:font1, font2;</code></li>
<li>font-display</li>
</ol>

<p>font-display 是为了自定义字体的使用方式。</p>

<p>默认是 auto。<code>auto</code>表示为了自定义字体的下载等待 3 秒。意味着，如果网速慢的话，用户看到内容需要等待三秒。</p>

<blockquote>
<p>edge 例外</p>
</blockquote>

<p>font-display: <code>fallback</code>。浏览器立马使用可获得字体（缓存的自定义字体或者回退字体）渲染文本。然后是，如果自定义字体没有缓存就下载它；如果 3 秒内下载完，浏览器将要使用自定义样式替换使用的回退字体。</p>

<p>font-display: <code>optional</code>。浏览器也会立马使用可以获得的字体（缓存的自定义字体或者回退字体）显示文本。然后，如果自定义字体没有缓存就下载它。但是即使定制的字体下载完成，也不会替换显示的字体，除非刷新浏览器。</p>

<h5 id="测试工具">测试工具</h5>

<h6 id="google-pagespeed-insight">Google PageSpeed Insight</h6>

<h6 id="light-house">Light House</h6>

<h6 id="web-page-test">Web Page Test</h6>

<h6 id="webpack-bundle-analyzer">webpack-bundle-analyzer</h6>

<h3 id="运行快">运行快</h3>

<p>加载之后工作流畅，动画不挑针，滑动流畅</p>

<h2 id="参考链接">参考链接</h2>

<p><a href="https://3perf.com/talks/web-perf-101/#perf-importance-horror">3perf</a></p>

</div>

    </main>

    <footer>
        
        
        
    </footer>

</body>

</html>